/// @file parlio_transmitter.cpp
/// @brief Implementation of PARLIO transmitter class

#if defined(ESP32)
#include "sdkconfig.h"

#if defined(CONFIG_IDF_TARGET_ESP32P4)

#include "parlio_transmitter.h"
#include "parlio_hub.h"          // ParlioHub
#include "fl/pixel_iterator.h"   // fl::PixelIterator
#include "fl/chipsets/led_timing.h"   // TIMING_WS2812_800KHZ, WS2812ChipsetTiming
#include "fl/singleton.h"        // fl::Singleton
#include "fl/map.h"              // fl::SortedHeapMap for chipset registry
#include "fl/unique_ptr.h"       // fl::unique_ptr

// ParlioTransmitterBase is defined in clockless_parlio_esp32p4.cpp (anonymous namespace)
// Forward declaration of factory function
namespace fl {
class ParlioTransmitterBase;
ParlioTransmitterBase* createParlioTransmitterBase(const ChipsetTimingConfig& timing);
}

namespace fl {

// ===== Concrete implementation of IParlioTransmitter interface =====

/// @brief Concrete wrapper that implements IParlioTransmitter interface
///
/// Delegates all operations to ParlioTransmitterBase implementation.
/// This class bridges the abstract interface to the concrete implementation.
class ParlioTransmitter : public IParlioTransmitter {
public:
    explicit ParlioTransmitter(const ChipsetTimingConfig& timing)
        : mBase(createParlioTransmitterBase(timing))
        , mTiming(timing)
    {
        // Register with ParlioHub for cross-chipset coordination
        ParlioHub::getInstance().registerTransmitter(
            this,
            [](void* ptr) {
                static_cast<ParlioTransmitter*>(ptr)->flush();
            }
        );
    }

    ~ParlioTransmitter() override {
        // Unregister from ParlioHub
        ParlioHub::getInstance().unregisterTransmitter(this);
        delete mBase;
    }

    // Interface implementation - delegate to mBase
    void onQueuingStart() override {
        mBase->onQueuingStart();
    }

    bool isQueuing() const override {
        return mBase->isQueuing();
    }

    void onQueuingDone() override {
        mBase->onQueuingDone();
    }

    void addStrip(uint8_t pin, uint16_t numLeds, bool is_rgbw) override {
        mBase->addObject(pin, numLeds, is_rgbw);
    }

    void writePixels(uint8_t data_pin, PixelIterator& pixel_iterator) override {
        mBase->writePixels(data_pin, pixel_iterator);
    }

    void flush() override {
        mBase->showPixelsOnceThisFrame();
    }

private:
    ParlioTransmitterBase* mBase;       ///< Implementation pointer
    ChipsetTimingConfig mTiming;        ///< Chipset timing config for this instance
};

// ===== Static registry and factory functions =====

// Static registry mapping timing configs to IParlioTransmitter instances
static fl::SortedHeapMap<uint32_t, IParlioTransmitter*>& getTransmitterRegistry() {
    static fl::SortedHeapMap<uint32_t, IParlioTransmitter*> registry;
    return registry;
}

// Hash function for ChipsetTimingConfig
static uint32_t hashTiming(const ChipsetTimingConfig& timing) {
    // Simple hash: XOR all timing values
    return timing.t1_ns ^ timing.t2_ns ^ timing.t3_ns ^ timing.reset_us;
}

// Runtime factory function - directly uses timing config
IParlioTransmitter& IParlioTransmitter::getOrCreate(const ChipsetTimingConfig& timing) {
    // Hash the timing to find existing instance
    uint32_t hash = hashTiming(timing);

    auto& registry = getTransmitterRegistry();
    auto it = registry.find(hash);

    if (it != registry.end()) {
        return *it->second;
    }

    // Create new instance
    IParlioTransmitter* transmitter = new ParlioTransmitter(timing);
    registry[hash] = transmitter;

    return *transmitter;
}

// Templated factory function - converts compile-time CHIPSET to runtime config
template <typename CHIPSET>
IParlioTransmitter& IParlioTransmitter::getOrCreate() {
    // Convert compile-time CHIPSET to runtime config and delegate to runtime version
    return getOrCreate(makeTimingConfig<CHIPSET>());
}

// Explicit template instantiations for common chipsets
template IParlioTransmitter& IParlioTransmitter::getOrCreate<TIMING_WS2812_800KHZ>();
template IParlioTransmitter& IParlioTransmitter::getOrCreate<TIMING_WS2813>();
template IParlioTransmitter& IParlioTransmitter::getOrCreate<TIMING_WS2816>();
template IParlioTransmitter& IParlioTransmitter::getOrCreate<TIMING_SK6812>();
template IParlioTransmitter& IParlioTransmitter::getOrCreate<TIMING_APA102>();

}  // namespace fl

#endif // CONFIG_IDF_TARGET_ESP32P4
#endif // ESP32
