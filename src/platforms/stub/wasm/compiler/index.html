<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>FastLED.js</title>

    <!-- Include Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@300&display=swap" rel="stylesheet">

    <style>
        body {
            background-color: #121212; /* Dark gray background */
            color: #E0E0E0; /* Light gray text */
            margin: 0;
            padding: 0;
            font-family: 'Roboto Condensed', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            opacity: 0; /* Initially hide the content */
            transition: opacity 0.5s ease-in; /* Fade-in effect */
        }

        h1 {
            font-size: 6em;
            margin-top: 10vh;
            margin-bottom: 40px;
            text-align: center;
            font-weight: 300;
            letter-spacing: 1px;
            line-height: 1.2;
            position: relative;
            animation: continuousGlow 4s ease-in-out infinite;
        }

        @keyframes continuousGlow {
            0% { text-shadow: 0 0 5px rgba(224, 224, 224, 0.1); }
            25% { text-shadow: 0 0 20px rgba(224, 224, 224, 0.3); }
            50% { text-shadow: 0 0 30px rgba(224, 224, 224, 0.5); }
            75% { text-shadow: 0 0 20px rgba(224, 224, 224, 0.3); }
            100% { text-shadow: 0 0 5px rgba(224, 224, 224, 0.1); }
        }

        #canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
        }

        #myCanvas {
            background-color: #1E1E1E; /* Slightly lighter gray for contrast */
            width: 320px;
            height: 320px;
            image-rendering: pixelated;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2); /* Outer shadow */
        }

        #output {
            font-size: 1em;
            padding: 20px;
            white-space: pre-wrap;
        }
    </style>


</head>

<body>
    <h1>FastLED.js</h1>
    <div id="canvas-container">
        <canvas id="myCanvas" width="16" height="16"></canvas>
        <script id="vertexShader" type="x-shader/x-vertex">
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            varying vec2 v_texCoord;
            void main() {
                gl_Position = vec4(a_position, 0, 1);
                v_texCoord = a_texCoord;
            }
        </script>
        <script id="fragmentShader" type="x-shader/x-fragment">
            precision mediump float;
            uniform sampler2D u_image;
            varying vec2 v_texCoord;
            void main() {
                gl_FragColor = texture2D(u_image, v_texCoord);
            }
        </script>
    </div>
    <pre id="output"></pre>

    <!-- Include the FastLED script -->
    <script src="fastled.js"></script>
</body>

<script>
    const FRAME_RATE = 60; // 60 FPS
    const CANVAS_SIZE = 16; // 16x16 initial canvas size

    globalThis.onFastLedSetCanvasSize = function (jsonStr) {
        const jsonData = JSON.parse(jsonStr);
        const canvas = document.getElementById('myCanvas');

        const first = jsonData[0];  // one canvas information per controller, just assume one for now.
        const width = first.width;
        const height = first.height;
        canvas.width = width;
        canvas.height = height;
        
        const maxDisplaySize = 640; // Maximum display size in pixels
        const scaleFactor = Math.min(maxDisplaySize / width, maxDisplaySize / height, 20);
        
        canvas.style.width = Math.round(width * scaleFactor) + 'px';
        canvas.style.height = Math.round(height * scaleFactor) + 'px';
        console.log(`Canvas size set to ${width}x${height}, displayed at ${canvas.style.width}x${canvas.style.height}`);
    };
    globalThis.onFastLedFrame = function (frameData) {
        updateCanvas(frameData.getFirstPixelData_Uint8());
    };

    // Function to call the setup and loop functions
    function runFastLED(extern_setup, extern_loop, frame_rate, moduleInstance) {
        console.log("Calling setup function...");
        extern_setup();

        console.log("Starting loop...");
        const frameInterval = 1000 / frame_rate;
        let lastFrameTime = 0;

        // Executes every frame but only runs the loop function at the specified frame rate
        function runLoop(currentTime) {
            if (currentTime - lastFrameTime >= frameInterval) {
                extern_loop();
                lastFrameTime = currentTime;
            }
            requestAnimationFrame(runLoop);
        }
        requestAnimationFrame(runLoop);
    }


    let gl, program, positionBuffer, texCoordBuffer, texture;

    function initWebGL() {
        const canvas = document.getElementById('myCanvas');
        gl = canvas.getContext('webgl');
        if (!gl) {
            console.error('WebGL not supported');
            return;
        }

        // Create shaders
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, document.getElementById('vertexShader').text);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fragmentShader').text);

        // Create program
        program = createProgram(gl, vertexShader, fragmentShader);

        // Create buffers
        positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

        texCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), gl.STATIC_DRAW);

        // Create texture
        texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    }

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('Shader compile error:', gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
            return null;
        }
        return program;
    }

    function updateCanvas(data) {
        if (!gl) initWebGL();

        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            gl.RGB,
            gl.canvas.width,
            gl.canvas.height,
            0,
            gl.RGB,
            gl.UNSIGNED_BYTE,
            data
        );

        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(program);

        const positionLocation = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
        gl.enableVertexAttribArray(texCoordLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }

    // Ensure we wait for the module to load
    const onModuleLoaded = async () => {
        // Unpack the module functions and send them to the runFastLED function
        function __runFastLED(moduleInstance, frame_rate) {
            const exports_exist = moduleInstance && moduleInstance._extern_setup && moduleInstance._extern_loop;
            if (!exports_exist) {
                console.error("FastLED setup or loop functions are not available.");
                return;
            }
            return runFastLED(moduleInstance._extern_setup, moduleInstance._extern_loop, frame_rate, moduleInstance);
        }
        try {
            if (typeof fastled === 'function') {
                // Load the module
                fastled().then(instance => {
                    console.log("Module loaded, running FastLED...");
                    __runFastLED(instance, FRAME_RATE);
                }).catch(err => {
                    console.error("Error loading fastled as a module:", err);
                });
            } else {
                console.log("Could not detect a valid module loading for FastLED.");
            }
        } catch (error) {
            console.error("Failed to load FastLED:", error);
        }
    };

    // Wait for fonts to load before showing content
    if (document.fonts && document.fonts.ready) {
        document.fonts.ready.then(function () {
            document.body.style.opacity = 1;
        });
    } else {
        // Fallback for browsers that do not support document.fonts
        window.onload = function () {
            document.body.style.opacity = 1;
        };
    }

    // Bind the window.onload event to the onModuleLoaded function.
    window.addEventListener('load', onModuleLoaded);
</script>

</html>
