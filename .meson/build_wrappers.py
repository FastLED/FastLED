#!/usr/bin/env python3
"""
Build script for sccache wrapper trampolines.
Automatically compiles C wrappers on first use or when source changes.
"""

import sys
import os
import subprocess
import hashlib
from pathlib import Path

SCRIPT_DIR = Path(__file__).parent

# Wrapper source template
WRAPPER_TEMPLATE = """/*
 * Binary wrapper for Zig {compiler_type} compiler with sccache support
 * Auto-generated by build_wrappers.py - do not edit manually
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef _WIN32
#include <windows.h>
#define PATH_SEP 92  // backslash
#else
#include <unistd.h>
#define PATH_SEP 47  // forward slash
#endif

#define MAX_CMD_LEN 32768

int main(int argc, char *argv[]) {{
    const char *inner_wrapper = "{inner_wrapper}";

#ifdef _WIN32
    char exe_path[MAX_PATH];
    char script_dir[MAX_PATH];
    GetModuleFileNameA(NULL, exe_path, MAX_PATH);
    
    char *last_sep = strrchr(exe_path, PATH_SEP);
    if (last_sep) {{
        *last_sep = 0;
        strcpy(script_dir, exe_path);
    }} else {{
        strcpy(script_dir, ".");
    }}

    char python_exe[MAX_PATH];
    char inner_wrapper_path[MAX_PATH];
    sprintf(python_exe, "%s%c..%c.venv%cScripts%cpython.exe", script_dir, PATH_SEP, PATH_SEP, PATH_SEP, PATH_SEP);
    sprintf(inner_wrapper_path, "%s%c%s", script_dir, PATH_SEP, inner_wrapper);

    char cmdline[MAX_CMD_LEN];
    int offset = sprintf(cmdline, "\\"%s\\" \\"%s\\"", python_exe, inner_wrapper_path);
    
    for (int i = 1; i < argc; i++) {{
        if (strchr(argv[i], ' ')) {{
            offset += sprintf(cmdline + offset, " \\"%s\\"", argv[i]);
        }} else {{
            offset += sprintf(cmdline + offset, " %s", argv[i]);
        }}
    }}

    STARTUPINFOA si = {{sizeof(si)}};
    PROCESS_INFORMATION pi;
    
    if (!CreateProcessA(NULL, cmdline, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {{
        return 1;
    }}

    WaitForSingleObject(pi.hProcess, INFINITE);
    
    DWORD exit_code = 0;
    GetExitCodeProcess(pi.hProcess, &exit_code);
    
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    return (int)exit_code;
#else
    // Unix/Linux implementation
    char exe_path[4096];
    ssize_t len = readlink("/proc/self/exe", exe_path, sizeof(exe_path) - 1);
    if (len == -1) {{
        // Fallback for macOS and other systems
        strcpy(exe_path, argv[0]);
    }} else {{
        exe_path[len] = '\0';
    }}
    
    char *last_sep = strrchr(exe_path, PATH_SEP);
    char script_dir[4096];
    if (last_sep) {{
        *last_sep = '\0';
        strcpy(script_dir, exe_path);
    }} else {{
        strcpy(script_dir, ".");
    }}

    char python_exe[4096];
    char inner_wrapper_path[4096];
    sprintf(python_exe, "%s/../.venv/bin/python", script_dir);
    sprintf(inner_wrapper_path, "%s/%s", script_dir, inner_wrapper);

    // Build argument list for execv
    char **new_argv = malloc((argc + 2) * sizeof(char*));
    new_argv[0] = python_exe;
    new_argv[1] = inner_wrapper_path;
    for (int i = 1; i < argc; i++) {{
        new_argv[i + 1] = argv[i];
    }}
    new_argv[argc + 1] = NULL;

    execv(python_exe, new_argv);
    
    // If execv returns, it failed
    perror("execv");
    return 1;
#endif
}}
"""

def get_file_hash(filepath):
    """Calculate SHA256 hash of a file."""
    if not filepath.exists():
        return None
    sha256 = hashlib.sha256()
    with open(filepath, 'rb') as f:
        sha256.update(f.read())
    return sha256.hexdigest()

def needs_rebuild(source_file, binary_file):
    """Check if binary needs to be rebuilt."""
    if not binary_file.exists():
        return True
    
    # Check if source is newer
    if not source_file.exists():
        return True
    
    if source_file.stat().st_mtime > binary_file.stat().st_mtime:
        return True
    
    # Check hash file
    hash_file = binary_file.with_suffix(binary_file.suffix + '.hash')
    if not hash_file.exists():
        return True
    
    current_hash = get_file_hash(source_file)
    stored_hash = hash_file.read_text().strip()
    
    return current_hash != stored_hash

def build_wrapper(compiler_type, inner_wrapper):
    """Build a single wrapper trampoline."""
    source_file = SCRIPT_DIR / f"zig-{compiler_type}-wrapper.c"
    
    # Determine binary extension
    binary_ext = ".exe" if sys.platform == "win32" else ""
    binary_file = SCRIPT_DIR / f"zig-{compiler_type}-wrapper{binary_ext}"
    
    # Check if rebuild is needed
    if not needs_rebuild(source_file, binary_file):
        print(f"✓ {binary_file.name} is up to date")
        return True
    
    print(f"Building {binary_file.name}...")
    
    # Generate source code
    source_code = WRAPPER_TEMPLATE.format(
        compiler_type=compiler_type.upper(),
        inner_wrapper=inner_wrapper
    )
    source_file.write_text(source_code)
    
    # Compile using zig cc (available from ziglang Python package)
    try:
        # Try to use uv run python -m ziglang first
        result = subprocess.run(
            [sys.executable, "-m", "ziglang", "cc", str(source_file), "-o", str(binary_file)],
            capture_output=True,
            text=True
        )
        
        if result.returncode != 0:
            print(f"Error compiling {source_file.name}:")
            print(result.stderr)
            return False
        
        # Store hash for future checks
        hash_file = binary_file.with_suffix(binary_file.suffix + '.hash')
        current_hash = get_file_hash(source_file)
        hash_file.write_text(current_hash)
        
        print(f"✓ Built {binary_file.name} ({binary_file.stat().st_size} bytes)")
        return True
        
    except Exception as e:
        print(f"Error building wrapper: {e}")
        return False

def main():
    """Build all required wrapper trampolines."""
    print("Building sccache wrapper trampolines...")
    
    wrappers = [
        ("cc", "zig-cc.py"),
        ("cxx", "zig-cxx.py"),
    ]
    
    success = True
    for compiler_type, inner_wrapper in wrappers:
        if not build_wrapper(compiler_type, inner_wrapper):
            success = False
    
    if success:
        print("\n✓ All wrappers built successfully")
        return 0
    else:
        print("\n✗ Some wrappers failed to build")
        return 1

if __name__ == "__main__":
    sys.exit(main())
