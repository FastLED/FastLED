#!/bin/bash

set -e

# Arrays to track linting stages and their durations
declare -a LINT_STAGES=()
declare -a LINT_DURATIONS=()
declare -a LINT_SKIPPED=()

# Temp files for parallel lint output
PARALLEL_TMPDIR=$(mktemp -d)
trap "rm -rf $PARALLEL_TMPDIR" EXIT

# Function to record a linting stage's duration
record_stage() {
    local stage_name="$1"
    local duration="$2"
    local skipped="${3:-false}"
    LINT_STAGES+=("$stage_name")
    LINT_DURATIONS+=("$duration")
    LINT_SKIPPED+=("$skipped")
}

# Function to get elapsed seconds since a start time
get_elapsed_seconds() {
    local start_time=$1
    local end_time=$(date +%s)
    echo $((end_time - start_time))
}

# Parse command line arguments
JS_ONLY=false
CPP_ONLY=false
NO_FINGERPRINT=false
RUN_IWYU=false
RUN_FULL=false
RUN_PYRIGHT=false
while [[ $# -gt 0 ]]; do
    case $1 in
        --help|-h)
            echo "Usage: bash lint [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --help            Show this help message"
            echo "  --js              Run JavaScript linting only"
            echo "  --cpp             Run C++ linting only"
            echo "  --no-fingerprint  Force re-run all linters (skip timestamp checks)"
            echo "  --full            Run all linters including IWYU (Include-What-You-Use)"
            echo "  --iwyu            Run IWYU (Include-What-You-Use) analysis only"
            echo "  --strict          Also run pyright (slow strict type checker, ~12s)"
            echo ""
            echo "This script runs comprehensive linting for Python, C++, and JavaScript."
            echo "Python linting includes: ruff (lint + format) + KBI checker + ty."
            echo "Use --strict to also run pyright (strict type checking, adds ~12s)."
            echo "C++ linting includes: clang-format and custom checkers."
            echo "IWYU (Include-What-You-Use) runs ONLY with --full or --iwyu flags."
            echo "JavaScript linting: FAST ONLY (skips if not available)."
            exit 0
            ;;
        --js)
            JS_ONLY=true
            shift
            ;;
        --cpp)
            CPP_ONLY=true
            shift
            ;;
        --no-fingerprint)
            NO_FINGERPRINT=true
            shift
            ;;
        --full)
            RUN_FULL=true
            shift
            ;;
        --iwyu)
            RUN_IWYU=true
            shift
            ;;
        --strict)
            RUN_PYRIGHT=true
            shift
            ;;
        *)
            echo "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Unset VIRTUAL_ENV to avoid warnings about mismatched paths
unset VIRTUAL_ENV

# Remove Visual Studio project files if they exist
find tests/ -name "*.vcxproj" -exec rm {} \; 2>/dev/null || true
find tests/ -name "*.vcxproj.filters" -exec rm {} \; 2>/dev/null || true
find tests/ -name "*.sln" -exec rm {} \; 2>/dev/null || true

if [ "$JS_ONLY" = true ]; then
    echo "üåê Running JavaScript Linting Only"
    echo "==================================="
elif [ "$CPP_ONLY" = true ]; then
    echo "üîß Running C++ Linting Only"
    echo "============================"
else
    echo "üöÄ Running FastLED Comprehensive Linting Suite"
    echo "=============================================="
fi

# ============================================================================
# Helper functions for parallel lint stages
# ============================================================================

# Run C++ lint stage (called as background job or inline)
run_cpp_lint_stage() {
    local logfile="$1"
    local no_fingerprint="$2"
    local run_full="$3"
    local run_iwyu="$4"
    local start_time=$(date +%s)
    local skipped=false

    {
        export CLANG_FORMAT_STYLE="{SortIncludes: false}"

        echo ""
        echo "üîß C++ LINTING"
        echo "---------------"

        local needs_cpp_lint=false
        if [ "$no_fingerprint" = true ]; then
            echo "Running C++ linting (--no-fingerprint flag set)"
            needs_cpp_lint=true
        else
            if uv run python ci/cpp_lint_cache.py check; then
                needs_cpp_lint=true
            else
                needs_cpp_lint=false
            fi
        fi

        if [ "$needs_cpp_lint" = true ]; then
            folders=(
                #"src/lib8tion"
                #"src/platforms/stub"
                #"src/platforms/apollo3"  # clang-format breaks apollo3
                #"src/platforms/esp/8266"  # clang-format breaks esp8266
                #"src/platforms/arm" # clang-format breaks arm
                #"src/fx"
                #"src/fl"
                #"src/platforms/wasm"
            )

            for folder in "${folders[@]}"; do
              echo "Running clang-format on $folder"
              uv run ci/run-clang-format.py -i -r "$folder" || uv run ci/run-clang-format.py -i -r "$folder"
            done

            echo ""
            echo "üîç C++ CUSTOM LINTERS (UNIFIED)"
            echo "-------------------------------"
            echo "Running unified C++ checker (all linters + unity build + cpp_lint in one pass)"
            if uv run python ci/lint_cpp/run_all_checkers.py; then
                if [ "$no_fingerprint" != true ]; then
                    uv run python ci/cpp_lint_cache.py success
                fi
                echo "‚úÖ C++ linting passed"
            else
                if [ "$no_fingerprint" != true ]; then
                    uv run python ci/cpp_lint_cache.py failure
                fi
                echo "‚ùå Unified C++ linter failed"
                exit 1
            fi
        else
            skipped=true
        fi

        local cpp_duration=$(( $(date +%s) - start_time ))
        echo "DURATION:${cpp_duration}" >> "$logfile.meta"
        echo "SKIPPED:${skipped}" >> "$logfile.meta"

        # IWYU analysis
        echo ""
        echo "üîç INCLUDE-WHAT-YOU-USE ANALYSIS"
        echo "---------------------------------"

        local iwyu_start=$(date +%s)
        local iwyu_skipped=false

        if [ "$run_full" = true ] || [ "$run_iwyu" = true ]; then
            echo "Running IWYU on C++ test suite..."
            if uv run python ci/ci-iwyu.py --quiet; then
                echo "‚úÖ IWYU analysis passed"
            else
                echo "‚ùå IWYU analysis failed"
                exit 1
            fi
        else
            iwyu_skipped=true
            echo "‚è≠Ô∏è  IWYU skipped (use --full or --iwyu to enable)"
        fi

        local iwyu_duration=$(( $(date +%s) - iwyu_start ))
        echo "IWYU_DURATION:${iwyu_duration}" >> "$logfile.meta"
        echo "IWYU_SKIPPED:${iwyu_skipped}" >> "$logfile.meta"
    } > "$logfile" 2>&1
}

# Run JavaScript lint stage (called as background job or inline)
run_js_lint_stage() {
    local logfile="$1"
    local no_fingerprint="$2"
    local start_time=$(date +%s)

    {
        echo ""
        echo "üåê JAVASCRIPT LINTING & TYPE CHECKING"
        echo "--------------------------------------"

        RED='\033[0;31m'
        GREEN='\033[0;32m'
        BLUE='\033[0;34m'
        NC='\033[0m'

        if [ "$no_fingerprint" = true ]; then
            export FASTLED_NO_FINGERPRINT=1
        fi

        ESLINT_EXE=""
        if [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" || "$OSTYPE" == "win32" ]]; then
            ESLINT_EXE=".cache/js-tools/node_modules/.bin/eslint.cmd"
        else
            ESLINT_EXE=".cache/js-tools/node_modules/.bin/eslint"
        fi

        if [ -f "ci/lint-js-fast" ] && [ -f "$ESLINT_EXE" ]; then
            echo -e "${BLUE}üöÄ Using fast JavaScript linting (Node.js + ESLint)${NC}"
            if ! bash ci/lint-js-fast; then
                echo -e "${RED}‚ùå Fast JavaScript linting failed${NC}"
                exit 1
            fi
        else
            echo -e "${BLUE}‚ö†Ô∏è  Fast JavaScript linting not available. Setting up now...${NC}"
            if uv run ci/setup-js-linting-fast.py; then
                echo -e "${GREEN}‚úÖ JavaScript linting setup complete${NC}"
                if [ -f "ci/lint-js-fast" ]; then
                    echo -e "${BLUE}üöÄ Running JavaScript linting...${NC}"
                    if ! bash ci/lint-js-fast; then
                        echo -e "${RED}‚ùå JavaScript linting failed${NC}"
                        exit 1
                    fi
                else
                    echo -e "${RED}‚ùå Failed to create lint script${NC}"
                    exit 1
                fi
            else
                echo -e "${RED}‚ùå Failed to setup JavaScript linting${NC}"
                echo -e "${BLUE}üí° You can manually run: uv run ci/setup-js-linting-fast.py${NC}"
            fi
        fi

        local duration=$(( $(date +%s) - start_time ))
        echo "DURATION:${duration}" >> "$logfile.meta"
    } > "$logfile" 2>&1
}

# ============================================================================
# Parallel execution strategy:
#   - Full lint: C++ and JS start immediately in parallel with ruff+ty+pyright
#     (C++/JS are independent of Python files, only pyright depends on ruff)
#   - Single-mode (--cpp/--js): Run that stage inline
# ============================================================================

# Determine which stages to run
RUN_PYTHON=false
RUN_CPP=false
RUN_JS=false

if [ "$JS_ONLY" = false ] && [ "$CPP_ONLY" = false ]; then
    RUN_PYTHON=true
fi
if [ "$JS_ONLY" = false ]; then
    RUN_CPP=true
fi
if [ "$CPP_ONLY" = false ]; then
    RUN_JS=true
fi

# Count how many parallel stages will run (C++ and JS can overlap with Python)
PARALLEL_COUNT=0
[ "$RUN_PYTHON" = true ] && ((PARALLEL_COUNT++)) || true
[ "$RUN_CPP" = true ] && ((PARALLEL_COUNT++)) || true
[ "$RUN_JS" = true ] && ((PARALLEL_COUNT++)) || true

if [ $PARALLEL_COUNT -gt 1 ]; then
    echo ""
    echo "‚ö° PARALLEL LINTING (${PARALLEL_COUNT} stages)"
    echo "================================"

    PARALLEL_START=$(date +%s)
    PARALLEL_PIDS=()
    PARALLEL_NAMES=()

    # Launch C++ and JS immediately - they're independent of Python files
    if [ "$RUN_CPP" = true ]; then
        run_cpp_lint_stage "$PARALLEL_TMPDIR/cpp.log" "$NO_FINGERPRINT" "$RUN_FULL" "$RUN_IWYU" &
        PARALLEL_PIDS+=($!)
        PARALLEL_NAMES+=("cpp_linting")
        echo "  Started C++ linting (PID $!)"
    fi

    if [ "$RUN_JS" = true ]; then
        run_js_lint_stage "$PARALLEL_TMPDIR/js.log" "$NO_FINGERPRINT" &
        PARALLEL_PIDS+=($!)
        PARALLEL_NAMES+=("javascript_linting")
        echo "  Started JavaScript linting (PID $!)"
    fi

    # Run Python pipeline: ruff+ty (sequential), then optionally pyright (--strict)
    if [ "$RUN_PYTHON" = true ]; then
        # ruff+ty run as a single background pipeline, pyright only with --strict
        (
            PYTHON_LOGFILE="$PARALLEL_TMPDIR/python.log"
            {
                # Phase A: ruff (fixes Python files)
                RUFF_START=$(date +%s)
                echo "Running ruff check (linting + import sorting)"
                uv run ruff check --fix test.py
                uv run ruff check --fix ci --exclude ci/tmp/ --exclude ci/wasm/
                echo "Running ruff format (formatting)"
                uv run ruff format test.py
                uv run ruff format ci --exclude ci/tmp/ --exclude ci/wasm/
                echo "Running KeyboardInterrupt handler checks"
                uv run python ci/lint_python/keyboard_interrupt_checker.py test.py ci --exclude ci/tmp ci/wasm .pio
                echo "Running sys.path.insert/append checks"
                uv run python ci/lint_python/sys_path_checker.py test.py ci --exclude ci/tmp ci/wasm .pio
                RUFF_DURATION=$(( $(date +%s) - RUFF_START ))
                echo "RUFF_DURATION:${RUFF_DURATION}" >> "$PYTHON_LOGFILE.meta"
                echo "‚úÖ ruff passed (${RUFF_DURATION}s)"

                # Phase B: ty (fast type check, runs after ruff fixes)
                TY_START=$(date +%s)
                echo "Running ty (fast type check)"
                if uv run ty check --output-format concise; then
                    echo "‚úÖ ty passed"
                else
                    echo "‚ùå ty failed"
                    exit 1
                fi
                TY_DURATION=$(( $(date +%s) - TY_START ))
                echo "TY_DURATION:${TY_DURATION}" >> "$PYTHON_LOGFILE.meta"

                # Phase C: pyright (only with --strict flag)
                PYRIGHT_START=$(date +%s)
                PYRIGHT_SKIPPED=false
                if [ "$RUN_PYRIGHT" = true ]; then
                    if [ "$NO_FINGERPRINT" = true ]; then
                        echo "Running pyright (--no-fingerprint flag set)"
                        NEEDS_PYRIGHT=true
                    else
                        if uv run python ci/python_lint_cache.py check; then
                            NEEDS_PYRIGHT=true
                        else
                            NEEDS_PYRIGHT=false
                        fi
                    fi

                    if [ "$NEEDS_PYRIGHT" = true ]; then
                        if uv run pyright --threads; then
                            if [ "$NO_FINGERPRINT" != true ]; then
                                uv run python ci/python_lint_cache.py success
                            fi
                            echo "‚úÖ pyright passed"
                        else
                            if [ "$NO_FINGERPRINT" != true ]; then
                                uv run python ci/python_lint_cache.py failure
                            fi
                            echo "‚ùå pyright failed"
                            exit 1
                        fi
                    else
                        PYRIGHT_SKIPPED=true
                    fi
                else
                    PYRIGHT_SKIPPED=true
                    echo "‚è≠Ô∏è  pyright skipped (use --strict to enable)"
                fi
                PYRIGHT_DURATION=$(( $(date +%s) - PYRIGHT_START ))
                echo "PYRIGHT_DURATION:${PYRIGHT_DURATION}" >> "$PYTHON_LOGFILE.meta"
                echo "PYRIGHT_SKIPPED:${PYRIGHT_SKIPPED}" >> "$PYTHON_LOGFILE.meta"
            } > "$PYTHON_LOGFILE" 2>&1
        ) &
        PARALLEL_PIDS+=($!)
        PARALLEL_NAMES+=("python_pipeline")
        if [ "$RUN_PYRIGHT" = true ]; then
            echo "  Started Python pipeline: ruff ‚Üí ty ‚Üí pyright (PID $!)"
        else
            echo "  Started Python pipeline: ruff ‚Üí ty (PID $!)"
        fi
    fi

    echo ""

    # Wait for all parallel stages and collect results
    PARALLEL_FAILED=false
    for i in "${!PARALLEL_PIDS[@]}"; do
        pid="${PARALLEL_PIDS[$i]}"
        name="${PARALLEL_NAMES[$i]}"
        if wait "$pid"; then
            echo "  ‚úÖ ${name} completed"
        else
            echo "  ‚ùå ${name} FAILED"
            PARALLEL_FAILED=true
        fi
    done

    PARALLEL_DURATION=$(get_elapsed_seconds $PARALLEL_START)
    echo ""
    echo "  Parallel phase completed in ${PARALLEL_DURATION}s"

    # Print captured output from each stage
    for i in "${!PARALLEL_NAMES[@]}"; do
        name="${PARALLEL_NAMES[$i]}"
        logbase="$PARALLEL_TMPDIR"
        case "$name" in
            python_pipeline) logfile="$logbase/python.log" ;;
            cpp_linting) logfile="$logbase/cpp.log" ;;
            javascript_linting) logfile="$logbase/js.log" ;;
        esac
        if [ -f "$logfile" ]; then
            echo ""
            echo "--- ${name} output ---"
            cat "$logfile"
        fi
    done

    # Record durations from meta files
    if [ "$RUN_PYTHON" = true ]; then
        RUFF_DURATION=0
        TY_DURATION=0
        PYRIGHT_DURATION=0
        PYRIGHT_SKIPPED=false
        if [ -f "$PARALLEL_TMPDIR/python.log.meta" ]; then
            RUFF_DURATION=$(grep "^RUFF_DURATION:" "$PARALLEL_TMPDIR/python.log.meta" | head -1 | cut -d: -f2)
            TY_DURATION=$(grep "^TY_DURATION:" "$PARALLEL_TMPDIR/python.log.meta" | head -1 | cut -d: -f2)
            PYRIGHT_DURATION=$(grep "^PYRIGHT_DURATION:" "$PARALLEL_TMPDIR/python.log.meta" | head -1 | cut -d: -f2)
            PYRIGHT_SKIPPED=$(grep "^PYRIGHT_SKIPPED:" "$PARALLEL_TMPDIR/python.log.meta" | head -1 | cut -d: -f2)
        fi
        record_stage "ruff" "${RUFF_DURATION:-0}" false
        record_stage "ty" "${TY_DURATION:-0}" false
        record_stage "pyright" "${PYRIGHT_DURATION:-0}" "${PYRIGHT_SKIPPED:-false}"
    fi

    if [ "$RUN_CPP" = true ]; then
        CPP_LINT_DURATION=0
        CPP_LINT_SKIPPED=false
        IWYU_DURATION=0
        IWYU_SKIPPED=false
        if [ -f "$PARALLEL_TMPDIR/cpp.log.meta" ]; then
            CPP_LINT_DURATION=$(grep "^DURATION:" "$PARALLEL_TMPDIR/cpp.log.meta" | head -1 | cut -d: -f2)
            CPP_LINT_SKIPPED=$(grep "^SKIPPED:" "$PARALLEL_TMPDIR/cpp.log.meta" | head -1 | cut -d: -f2)
            IWYU_DURATION=$(grep "^IWYU_DURATION:" "$PARALLEL_TMPDIR/cpp.log.meta" | head -1 | cut -d: -f2)
            IWYU_SKIPPED=$(grep "^IWYU_SKIPPED:" "$PARALLEL_TMPDIR/cpp.log.meta" | head -1 | cut -d: -f2)
        fi
        record_stage "cpp_linting" "${CPP_LINT_DURATION:-0}" "${CPP_LINT_SKIPPED:-false}"
        record_stage "iwyu" "${IWYU_DURATION:-0}" "${IWYU_SKIPPED:-false}"
    fi

    if [ "$RUN_JS" = true ]; then
        JS_LINT_DURATION=0
        if [ -f "$PARALLEL_TMPDIR/js.log.meta" ]; then
            JS_LINT_DURATION=$(grep "^DURATION:" "$PARALLEL_TMPDIR/js.log.meta" | head -1 | cut -d: -f2)
        fi
        record_stage "javascript_linting" "${JS_LINT_DURATION:-0}" false
    fi

    # Fail if any parallel stage failed
    if [ "$PARALLEL_FAILED" = true ]; then
        echo ""
        echo "‚ùå One or more parallel lint stages failed"
        exit 1
    fi

else
    # Only one stage to run - run it inline (no parallelization needed)

    if [ "$RUN_CPP" = true ] && [ "$RUN_PYTHON" = false ] && [ "$RUN_JS" = false ]; then
        # Only C++ (--cpp flag)
        run_cpp_lint_stage "$PARALLEL_TMPDIR/cpp.log" "$NO_FINGERPRINT" "$RUN_FULL" "$RUN_IWYU"
        cat "$PARALLEL_TMPDIR/cpp.log"
        CPP_LINT_DURATION=0
        CPP_LINT_SKIPPED=false
        IWYU_DURATION=0
        IWYU_SKIPPED=false
        if [ -f "$PARALLEL_TMPDIR/cpp.log.meta" ]; then
            CPP_LINT_DURATION=$(grep "^DURATION:" "$PARALLEL_TMPDIR/cpp.log.meta" | head -1 | cut -d: -f2)
            CPP_LINT_SKIPPED=$(grep "^SKIPPED:" "$PARALLEL_TMPDIR/cpp.log.meta" | head -1 | cut -d: -f2)
            IWYU_DURATION=$(grep "^IWYU_DURATION:" "$PARALLEL_TMPDIR/cpp.log.meta" | head -1 | cut -d: -f2)
            IWYU_SKIPPED=$(grep "^IWYU_SKIPPED:" "$PARALLEL_TMPDIR/cpp.log.meta" | head -1 | cut -d: -f2)
        fi
        record_stage "cpp_linting" "${CPP_LINT_DURATION:-0}" "${CPP_LINT_SKIPPED:-false}"
        record_stage "iwyu" "${IWYU_DURATION:-0}" "${IWYU_SKIPPED:-false}"
    fi

    if [ "$RUN_JS" = true ] && [ "$RUN_PYTHON" = false ] && [ "$RUN_CPP" = false ]; then
        # Only JS (--js flag)
        run_js_lint_stage "$PARALLEL_TMPDIR/js.log" "$NO_FINGERPRINT"
        cat "$PARALLEL_TMPDIR/js.log"
        JS_LINT_DURATION=0
        if [ -f "$PARALLEL_TMPDIR/js.log.meta" ]; then
            JS_LINT_DURATION=$(grep "^DURATION:" "$PARALLEL_TMPDIR/js.log.meta" | head -1 | cut -d: -f2)
        fi
        record_stage "javascript_linting" "${JS_LINT_DURATION:-0}" false
    fi
fi

echo ""
if [ "$JS_ONLY" = true ]; then
    echo "üéâ JavaScript linting completed!"
elif [ "$CPP_ONLY" = true ]; then
    echo "üéâ C++ linting completed!"
else
    echo "üéâ All linting completed!"
fi

# Generate summary table
echo ""
echo "Linting Execution Summary:"

# Calculate column widths
max_name_width=0
for stage_name in "${LINT_STAGES[@]}"; do
    name_length=${#stage_name}
    if [ $name_length -gt $max_name_width ]; then
        max_name_width=$name_length
    fi
done

# Ensure minimum width for header
header_width=9  # Length of "Test Name"
if [ $max_name_width -lt $header_width ]; then
    max_name_width=$header_width
fi

# Print separator line
separator=""
for ((i=0; i<max_name_width; i++)); do separator="${separator}-"; done
separator="${separator}-+-"
for ((i=0; i<24; i++)); do separator="${separator}-"; done
echo "$separator"

# Print header
printf "%-${max_name_width}s | %24s\n" "Linter Name" "Duration"
echo "$separator"

# Print each stage
for i in "${!LINT_STAGES[@]}"; do
    stage_name="${LINT_STAGES[$i]}"
    duration="${LINT_DURATIONS[$i]}"
    skipped="${LINT_SKIPPED[$i]}"

    if [ "$skipped" = "true" ]; then
        printf "%-${max_name_width}s | %24s\n" "$stage_name" "Skipped (no changes)"
    else
        printf "%-${max_name_width}s | %23ss\n" "$stage_name" "$duration"
    fi
done

# Print final separator
echo "$separator"

echo ""
echo "üí° FOR AI AGENTS:"
echo "  - Use 'bash lint' for comprehensive linting (Python, C++, and JavaScript)"
echo "  - Use 'bash lint --strict' to also run pyright (strict type checking, adds ~12s)"
echo "  - Use 'bash lint --js' for JavaScript linting only"
echo "  - Use 'bash lint --cpp' for C++ linting only"
echo "  - Use 'bash lint --full' to include IWYU (Include-What-You-Use) analysis"
echo "  - Use 'bash lint --iwyu' to run IWYU analysis only"
echo "  - Python linting includes: ruff (lint + format) + KBI checker + ty"
echo "  - Use --strict to also run pyright (strict type checking)"
echo "  - C++ linting includes: clang-format and custom checkers"
echo "  - IWYU runs ONLY with --full or --iwyu flags"
echo "  - JavaScript linting: FAST ONLY (no slow fallback)"
echo "  - To enable fast JavaScript linting: uv run ci/setup-js-linting-fast.py"
echo "  - Use 'bash lint --help' for usage information"
